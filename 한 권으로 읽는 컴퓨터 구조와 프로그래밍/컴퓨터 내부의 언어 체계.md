## 언어란 무엇인가

## 문자언어

## 비트

모든 언어는 의미를 기호와 집합으로 encoding 한다. 

기호가 들어갈 상자
상자에 들어갈 기호
상자의 순서

상자? 

컴퓨터에서는 bit 

비트상자에는 두가지 기호 중 하나만 담을 수 있다. 

## 논리연산 

### Bool 대수 

### 드모르간의 법칙

## 정수를 비트로 표현하는 방법

### 부호없는 정수

상자가 표현하는 값  = 상자 자체 값 * 상자 안에 들어있는 값


LSB
= Least Significant Bit

MSB
= Most Significant Bit

### 2진수 덧셈

표현할 수 있는 숫자보다 커지면, 다음 자리로 올린다. 

두 비트를 서로 더한 결과는 두 비트를 XOR 한 값과 같다. 

올림은 두 비트를 AND 한 값과 같다.

### 부호 있는 정수

#### 부호와 크기

1. MSB 를 부호를 나타내는 비트로 사용하는 경우
    - 0이면 양수, 1이면 음수
    - 양수 0, 음수 0 각각 0 이 두개가 됨
    - 0 빼고는 표현하는데는 문제가 없으나, 계산할 때가 문제가 됨!


#### 1의 보수

    - 양수 0, 음수 0 각각 0 이 두개가 됨
    - 덧셈방법이 복잡하여 추가적인 하드웨어가 필요함

#### 2의 보수

- 더했을 때 0 이 나오는 비트 패턴을 찾자
- 어떤 숫자의 비트패턴 전부에 NOT 연산을 하고 1을 더하면 해당 숫자의 음수가 나온다. 
- 0 이 하나다! 


## 실수를 표현하는 방법

### 고정 소수점 표현법 

- 2.5 => 010.1

#### 고정 소수점의 한계

- 일반적인 문제를 해결하려면 어느정도 넓은 범위의 수를 표현할 수 있어야 한다.
- 단순 정수부, 실수부로 나누어 표현하면, 필요한 범위를 표현하기 위해 필요한 비트 수가 너무 많아져 메모리 낭비가 심하다.
- 그래서 비트 수가 정해진 부동 소수점 표현법이 등장하게 된다.

### 부동 소수점 표현법 (floating point representation)

- 가수는 정해져 있지만, 지수는 정해져 있지 않다. 
- 고정 소수점 표현법에서는 소수점의 위치가 고정되어 있었지만, 부동 소수점 표현법에서는 소수점의 위치가 고정되어 있지 않습니다.
- 때문에, 소수점이 "플로팅(부동)"하는 것처럼 보입니다. 이렇게 소수점의 위치를 자유롭게 움직일 수 있기 때문에 이런 방식을 "부동 소수점(floating point)"이라 부릅니다

#### Scientific Notation

- 1.2345 * 10^3
- 10 진 소수점 왼쪽이 한자리 뿐인 소수에 10을 몇번 곱한 것인지 표현하는 방법
- 가수(mantissa) 와 지수(exponent) 로 표현한다.
- 1.2345 = 가수
- 3 = 지수

#### IEEE 754 부동소수점 표준

- 정밀도를 높이기 위해 가수에 0이 없도록 함
- 가수에 0이 없도록 했기 때문에 첫번째 비트는 무조건 1이므로, 이를 생략하고 표현함
- 기본 정밀도는 32비트(float), 두배 정밀도는 64비트(double)로 표현함
- 기본 정밀도에서는 127을 biased value 로 사용함
    - 01111111이 지수 0 을 의미함


#### 지수에 biased(편향) 값을 사용하는 이유

- 음수 지수 표현: 기본적으로 컴퓨터는 음수를 표현하는 데 특정 비트를 사용합니다(2의 보수). 그러나 부동소수점 표현에서 지수에 편향을 추가함으로써, 지수가 음수인 경우에도 모두 양수로 처리할 수 있습니다. 이렇게 하면 부호 비트를 사용하지 않고도 음수 지수를 표현할 수 있습니다.

- 정렬 용이: 편향된 지수를 사용하면, 부동 소수점 수들이 자신의 값에 따라 정렬될 수 있습니다. 즉, 비트 패턴만으로도 부동 소수점 수들을 정렬할 수 있습니다. 이는 부동 소수점 수의 비교와 정렬을 훨씬 쉽게 만듭니다.

- 특수 값 표현: 편향을 사용함으로써, 지수 부분의 모든 비트가 0인 경우나 1인 경우 등을 특별한 값(예: 0, 무한대, Not a Number)으로 사용할 수 있습니다.

#### single precision 에서 편향치가 127인 이유

IEEE 754 부동 소수점 표준에서 단일 정밀도(single precision) 부동 소수점 숫자의 지수는 8비트를 사용합니다. 이 8비트 지수는 2의 7승인 128개의 가능한 값(0부터 127까지)을 가질 수 있습니다.

그런데 0과 255(2의 8승 - 1)는 특별한 값으로 예약되어 있습니다. 0은 비정규화된 숫자와 0을 표현하기 위해 사용되며, 255는 무한대와 NaN (Not a Number)을 표현하기 위해 사용됩니다.

따라서 실제로 지수로 사용할 수 있는 값의 범위는 1부터 254까지입니다. 이 범위를 편향(bias)하기 위해 선택할 수 있는 값은 그 중간 값인 127입니다. 이렇게 하면 지수가 음수(1-127), 0(127), 양수(127-254)의 모든 값들을 표현할 수 있게 됩니다.

#### 부동소수점이 근사값으로 표현되는 이유

컴퓨터에서 사용되는 이진(binary) 시스템의 특성과 부동소수점 표현법의 공간 한계 때문입니다.

이진 시스템의 특성: 컴퓨터는 이진 시스템을 사용하여 숫자를 표현하고 연산합니다. 이진 시스템에서는 실수를 이진 소수로 표현해야 하는데, 일부 실수는 이진 소수로 정확하게 표현할 수 없습니다. 예를 들어, 10진수의 0.1은 이진 소수로 무한 반복되는 소수(0.0001100110011...)입니다. 이러한 숫자는 컴퓨터에서 정확하게 표현할 수 없기 때문에 근사값으로 저장됩니다.

공간 한계: 부동소수점 표현법은 가수(mantissa)와 지수(exponent)를 사용하여 실수를 표현하며, 각각의 비트 수가 제한되어 있습니다. 이로 인해 표현 가능한 숫자들 사이에는 간격이 존재하게 됩니다. 따라서 표현 가능한 숫자들 사이에 있는 숫자는 가장 가까운 표현 가능한 숫자로 반올림되어 근사값으로 저장됩니다.

이러한 이유로 인해 부동소수점 표현법을 사용하는 컴퓨터에서는 실수를 근사값으로 표현하게 됩니다. 이로 인해 발생하는 반올림 오류와 오차 누적은 부동소수점 연산에서 주의해야 할 문제로 인식되어 있습니다. 이러한 한계를 이해하고 관리하는 것이 중요합니다.


#### IEEE 754 표준에 따른 부동소수점 표현 예시

싱글 프리시전(Single Precision)을 사용해 10진수의 숫자 42.625를 2진법으로 표현하는 과정을 살펴봅시다.

부호(Sign) 결정: 숫자 42.625는 양수이므로, 부호 비트는 0입니다.

이진수로 변환: 42.625를 이진수로 변환하면 101010.101입니다.

정규화: 이진수를 1.xxxx 형태로 변환해야 합니다. 소수점을 왼쪽으로 이동시켜서 정규화하면 1.01010101이 되며, 소수점이 5칸 이동했습니다. 따라서 지수는 5입니다.

지수에 편향치 더하기: 싱글 프리시전에서 지수의 편향치(bias)는 127입니다. 지수에 편향치를 더하면 5 + 127 = 132가 됩니다. 이 값을 이진수로 변환하면 10000100입니다.

가수(Mantissa) 추출: 정규화된 숫자 1.01010101에서 1.xxxx 형태의 가수를 추출합니다. 여기서 가수는 01010101입니다. 싱글 프리시전에서 가수는 23비트로 표현되므로, 추가적으로 0을 덧붙여 01010101000000000000000이 됩니다.

부동소수점 표현: 부호, 지수, 가수를 합쳐서 부동소수점 표현을 완성합니다.
부호: 0
지수: 10000100
가수: 01010101000000000000000
부동소수점: 01000010001010101000000000000000

따라서, IEEE 754 싱글 프리시전 표준을 사용하여 10진수 42.625를 2진 부동소수점으로 표현하면 01000010001010101000000000000000이 됩니다.

부호(Sign): 1비트
부호 비트는 양수(0) 또는 음수(1)를 나타냅니다.

지수(Exponent): 8비트
지수 부분은 실제 지수에 편향치(bias)를 더한 편향된 지수로 표현됩니다. 싱글 프리시전에서 편향치는 127입니다.

가수(Mantissa): 23비트
가수 부분은 정규화된 소수점 이하의 숫자들을 나타냅니다. 정규화된 형태에서 가수 앞의 1은 생략되어 저장됩니다.

> 0.625를 이진수로 변환하는 과정

소수 부분의 숫자에 2를 곱합니다: 0.625 × 2 = 1.25
이때 소수점 왼쪽의 숫자 1을 기록하고, 오른쪽의 소수 부분 0.25만 남깁니다.

남은 소수 부분에 다시 2를 곱합니다: 0.25 × 2 = 0.5
소수점 왼쪽의 숫자 0을 기록하고, 오른쪽의 소수 부분 0.5만 남깁니다.

남은 소수 부분에 다시 2를 곱합니다: 0.5 × 2 = 1.0
소수점 왼쪽의 숫자 1을 기록하고, 오른쪽의 소수 부분 0이 남습니다.

이제 더 이상 남은 소수 부분이 없으므로 변환을 중지합니다. 이전에 기록한 숫자들을 합쳐서 결과를 얻습니다: 0.101

따라서, 10진수 0.625를 이진수로 변환하면 0.101이 됩니다.

#### Bias 란? 

편향치(Bias)는 부동소수점 표현법에서 지수를 저장하기 위해 사용되는 기법입니다. 지수에 편향치를 더함으로써 음수와 양수 지수를 양수 값으로 매핑하여 표현할 수 있게 됩니다. 이렇게 하면 지수를 비교하는 것이 쉬워지고, 비트 패턴을 효율적으로 사용할 수 있습니다.

IEEE 754 표준에서는 편향된 지수를 사용해 지수를 표현합니다. 싱글 프리시전에서 편향치는 127입니다. 

편향치의 사용에는 다음과 같은 이유가 있습니다:

지수 부호 처리: 편향된 지수를 사용하면 지수의 부호를 고려할 필요가 없어집니다. 음수와 양수 지수를 모두 양수 값으로 매핑하여 저장할 수 있기 때문입니다.

부동소수점에서는 정규화 과정을 통해 음수지수를 별도로 표현하지 않을 수 있습니다. 예를 들어, 2진수 1.01010101은 2진수 0.000101010101을 5칸 왼쪽으로 이동시킨 것입니다. 이때 5칸 왼쪽으로 이동했으므로 지수는 -5가 됩니다. 하지만 편향치를 사용하면 지수를 양수로 표현할 수 있습니다. 5 + 127 = 132이므로, 지수를 132로 표현할 수 있습니다.

지수 비교 용이성: 편향치가 적용된 지수를 사용하면, 부동소수점 숫자들의 순서 비교가 간편해집니다. 부호와 지수만으로 두 숫자의 대소 관계를 비교할 수 있게 됩니다.

비트 패턴 효율성: 편향된 지수를 사용하면 지수에 대한 비트 패턴이 효율적으로 사용됩니다. 예를 들어, 지수 값이 모두 0일 때는 비정규화된 수를 표현하고, 지수 값이 모두 1일 때는 무한대와 NaN(Not a Number)를 표현할 수 있습니다.

따라서 편향치는 부동소수점 표현법에서 지수 부분을 효율적으로 관리하고 연산을 간소화하는 데 사용됩니다.

##### Bias 가 127인 이유

여기서 k는 지수부의 비트 수입니다.

지수 부분을 가능한 한 효율적으로 사용하려면 편향치를 통해 음수와 양수 지수를 균등하게 분포시키는 것이 좋습니다. 이를 위해 가용한 비트 수를 고려하여 편향치를 선택합니다.

공식에서 k-1이 나온 이유는 모든 가능한 지수를 고려하여 양수와 음수 지수를 가능한 한 균등하게 분포시키려는 의도 때문입니다. 2^(k-1)을 사용하면 가용한 지수 범위의 절반을 나타낼 수 있습니다.

그런데 여기서 왜 1을 빼는 것일까요? 1을 빼는 이유는 지수가 모두 0인 경우와 지수가 모두 1인 경우를 예약하기 위함입니다. 두 경우를 제외한 나머지 값들을 실제 지수를 나타내기 위해 사용합니다.

예를 들어, 싱글 프리시전에서 지수부는 8비트입니다. 그러면 2^(8-1) = 128이 되고, 이 값에서 1을 빼면 편향치는 127이 됩니다. 이렇게 편향치를 선택하면 실제 지수 범위는 -126부터 127까지가 되며, 효율적으로 지수를 표현할 수 있습니다.

결국, 2^(k-1) - 1 공식은 지수부의 비트 수를 고려하여 양수와 음수 지수를 균등하게 분포시키고, 지수가 모두 0인 경우와 지수가 모두 1인 경우를 예약하기 위해 사용됩니다.

싱글 프리시전에서 지수 부분은 8비트로 표현되므로, 가능한 값의 범위는 0부터 255(2^8 - 1)까지입니다.

하지만, 지수 부분의 모든 값이 실제 지수를 나타내는 데 사용되지는 않습니다. 지수 값이 모두 0인 경우와 모두 1인 경우는 특별한 값을 나타내기 위해 예약되어 있습니다. 지수가 모두 0일 때는 비정규화된 값(Denormalized numbers)을 표현하고, 지수가 모두 1일 때는 무한대와 NaN(Not a Number)를 표현합니다.

그러므로, 가능한 지수 값의 범위는 1부터 254가 됩니다. 편향치는 127이므로, 실제 지수는 -126부터 127로 나타낼 수 있습니다(-127은 0으로, 128은 255로 표현되기 때문입니다).

따라서, 실제 지수 범위는 -126부터 127입니다. 이 범위를 사용하면 부동소수점 표현의 효율성과 연산의 간소화를 도모할 수 있습니다.


### 2진수를 다루는 쉬운 방법

- 2진수는 너무 길어 사람이 읽기에 힘듦

#### 8진법 

- 2진수를 3자리씩 끊어서 8진수로 표현
- 128(10) = 10000000(2) = 200(8)

#### 16진법

- 2진수를 4자리씩 끊어서 16진수로 표현
- 128(10) = 0b10000000(2) = 0x80(16)
- 컴퓨터가 기본 8비트(1 byte) 단위로 데이터를 처리하기 때문에 4자리씩 끊는, 16진수가 편리하다.

### unicode

유니코드(Unicode)는 전 세계의 모든 문자에 고유한 16진수를 할당하는 국제 표준
예를 들어, 영어 알파벳 'A'의 유니코드 값은 U+0041입니다.

유니코드의 주요 장점은 다음과 같습니다:

언어 간 호환성: 유니코드는 서로 다른 언어의 문자를 동시에 사용할 수 있게 해줍니다. 따라서 사용자는 한 문서 안에서 여러 가지 언어를 자유롭게 섞어 사용할 수 있습니다.

표준화: 유니코드는 전 세계적으로 표준화되어 있습니다. 이는 서로 다른 시스템 간에 문자 데이터를 교환하는 데 있어 중요한 역할을 합니다.

확장성: 유니코드는 수많은 문자를 포함하고 있으며, 새로운 문자가 추가될 수 있는 공간도 여유롭게 남아 있습니다. 이를 통해 새로운 문자나 기호를 쉽게 추가할 수 있습니다.

이러한 이유로, 유니코드는 웹, 운영 체제, 언어 프로그래밍 등 다양한 분야에서 문자 인코딩 표준으로 널리 사용되고 있습니다.

#### UTF-8

UTF-8은 Unicode Transformation Format 8-bit의 약자로, 유니코드 문자를 8비트 단위로 인코딩하는 방법입니다. UTF-8은 모든 유니코드 문자를 표현할 수 있으며, ASCII 문자는 원래의 1바이트 크기를 유지합니다.

UTF-8이 등장한 배경에는 여러 가지 이유가 있습니다:

호환성: 과거에는 많은 시스템이 7비트 ASCII로 작동했었습니다. UTF-8은 기존 ASCII 문자를 그대로 유지하면서 다른 문자를 인코딩할 수 있기 때문에, 기존 시스템을 크게 변경하지 않고도 유니코드를 지원할 수 있게 되었습니다.

국제화: 인터넷의 발전으로 다양한 언어와 문자가 사용되게 되었고, 이에 대응하기 위해 모든 언어의 문자를 표현할 수 있는 표준이 필요했습니다. 유니코드는 이를 가능하게 했고, UTF-8은 유니코드를 효율적으로 인코딩하는 방법 중 하나입니다.

효율성: UTF-8은 각 문자의 인코딩 길이가 가변적입니다. ASCII 문자는 1바이트로, 대부분의 라틴계열 언어는 2바이트로, 그 외의 대부분의 문자는 3바이트로 인코딩됩니다. 이런 방식은 메모리를 효율적으로 사용할 수 있게 합니다.

따라서 UTF-8은 호환성, 국제화, 효율성 등의 이유로 널리 사용되게 되었습니다. 이제는 웹에서 가장 많이 사용되는 문자 인코딩 방식 중 하나입니다.